> 原文地址 https://www.cnblogs.com/andrewwang/p/11665836.html

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1570786841653&di=c11b53cab11b9b1f4fece5210cd4afcb&imgtype=0&src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-a75a1c17268a96f64e40e8a0c9efdc87_1200x500.jpg)

#### 前言

其实我一直弄不明白一点，那就是计算机技术的发展，是让这个世界变得简单了，还是变得更复杂了。
当然这只是一个玩笑，可别把这个问题当真。

然而对于 IT 从业者来说，这可不是一个玩笑。几乎每一次的技术发展，都让这个生态变得更为复杂。“英年早秃” 已经成为一种很普遍的现象。

Rust 是近两年呼声比较高的一种新型开发语言。市场占有量并不大，但增长速度极为迅猛。
有人统计过，在计算机行业，平均每 33.5 天就有一种所谓的新型开发语言面世，这还不包括很多企业内部、项目内部的内置简易流程工具。然而大浪淘沙，如今仍然占据着市场地位的，不过仍然是耳熟能详的有限几种。
作为新来的搅局者，Rust 到底值不值得学习并且在工作中应用呢？

先说结论，这里粗略的把开发者分为初学者、小有经验的常规工程师和资深开发者三类。
对于初学者，Rust 具有比较陡峭的学习曲线，虽然学习 Rust 能训练良好的编程习惯，从长远看对提高学习者的开发素养极具价值。但短期的大量付出很容易让初学者心力交瘁。并且尽管官方文档并不欠缺，但学习资料对于初学者来讲仍然是远远不够的。所以比较而言，得不偿失。因此建议初学者仍然由久经验证的语言入门加入软件开发的大家庭。比如说 C/Java/Python/Js 都是很好的入门选择。
对于有一定经验的常规工程师，他们已经有了一段时间的开发工作实践，对于软件开发的现状、发展都已经形成了自己的世界观。如果感觉并不很喜欢这个行业，希望将来转行管理岗位或者产品岗位。那当前应当做的更多是倾向业务领域，了解业务和技术的衔接和互动，完全不需要学习 Rust。而如果醉心于技术，并从中获得了自己的乐趣，希望逐步提高自己的技术水平。那么 Rust 会是一个很好的桥梁，哪怕仅仅学习 Rust 而并不将其应用于工作，也能让开发者从中获取大量的有益习惯和软件底层经验，从而形成自己良好的代码风格。
对于资深工程师，即便并不从而底层系统级的开发工作，Rust 也是一门很优秀的语言。它能弥补当前多种开发语言的不足，形成良好的开发哲学和思想导向，帮助开发者交付高质量的软件产品。因此，及早学习并应用 Rust 非常有价值。

为了说明这个结论，下面从多个角度，采用同传统语言对比的方式来说一说我对 Rust 的理解。

#### Rust 是一种全面创新的语言

这几年有不少有影响的语言出现，但大多数都只是关键字或者小范围的语法创新，随后可能会有大量的特色库函数来丰富语言的功能。一个有经验的开发者，可能翻两天资料，就能快速的掌握。
而 Rust 极具自身语言特点，是一种完全的创新，而不是简单的语法替换。简单的熟悉几个关键字和判断、循环等语法，远不足以掌握这门语言。
为了证明这一点，下面用 Rust 的 “所有权”(Ownership) 机制和“遮蔽”（Shadowing）来举例说明。

#### “所有权”机制 (Ownership) 和“遮蔽”（Shadowing）

以 C++ 为例，请看下面这段代码：

```
#include<iostream>
using namespace std;

int main(){
    string s1="hello";
    string s2=s1;
    cout << "s1=" << s1 << ",s2=" << s2 << endl;
    return 0;
}
```

编译执行后，程序输出：

```
s1=hello,s2=hello
```

代码再简单不过，首先声明、赋值一个字符串变量 s1，然后把变量 s1 赋值给变量 s2，最后输出两者的值。

对应的，我们看一个 Rust 的版本：

```
fn main(){
    let s1=String::from("hello");
    let s2=s1;
    println!("s1={},s2={}",s1,s2);
}
```

除了细小的语法差异，看上去跟 C++ 的版本没有什么不同。然而在 Rust 中，这段代码连编译都无法通过，得益于 rustc 编译程序详细的输出，我们能看到很细致的错误提示：

```
2 |     let s1=String::from("hello");
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2=s1;
  |            -- value moved here
4 |     println!("s1={},s2={}",s1,s2);
  |                            ^^ value borrowed here after move
```

这个编译错误是指，上面代码中，当变量 s1 赋值给 s2 之后，s1 变量名所指向的内存所有权，被 “转移”(move) 到了 s2 变量名拥有之下。而从此之后，s1 变量名就无效了，不再指向任何一块内存。除非重新声明并为 s1 赋值（Rust 中称为 Shadow,"遮蔽" 原有的 s1）,s1 不能再被使用。
所有权机制可以有效的防止内存泄露所导致的程序 Bug，是 Rust 内存管理的核心理念。上面提到的所有权 “转移” 是所有权管理的重要特征之一。

“遮蔽” 也是一个有趣的概念，Rust 的处理方式跟很多我们熟悉的语言不同。
请看下面 C 语言代码：

```
#include<stdio.h>

int main(){
    int x = 5;
    x = x+1;
    printf("x=%d\n", x);
}
```

这又是一段很基本的代码。首先声明、赋值一个整数变量 x, 接着把 x 的值加 1，再赋值回变量 x。这是各种开发语言中都常见的用法。编译执行的输出结果为`x=6`。
来看看 Rust 的版本：

```
fn main(){
    let x=5;
    x = x+1;
    println!("x={}", x);
}
```

很不幸，这段代码同样无法编译通过，错误是：

```
error[E0384]: cannot assign twice to immutable variable `x`
 --> test-own1.rs:3:5
  |
2 |     let x=5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     x = x+1;
  |     ^^^^^^^ cannot assign twice to immutable variable
```

rustc 这种 “图示” 型的输出信息让你排查错误更加方便。
错误的原因，在 Rust 中，默认所有变量都是只读类型的，除非在变量声明的时候就注明为可变类型 "mut"。
因此两次对于一个只读变量赋值导致编译错误。
解决的办法或者注明变量为可读写，这样同 C 语言的版本具有完全相同的意义：

```
let mut x=5;
```

或者用我们上面提到过的 “遮蔽” 机制：

```
fn main(){
    let x=5;
    let x = x+1;
    println!("x={}", x);
}
```

注意上面`x=x+1`，这一行的开始我们再次使用 let 关键字，这表示再次声明了变量 x。
与大多数语言不允许重复声明变量不同，这个 x 变量，跟第一次声明的变量 x 同名，并对其做出了 “遮蔽”。之后除非再次遮蔽变量 x，那起作用的，都将是本次新声明的 x。

通过这两个例子，可以看出 Rust 是从理念上做出了大量创新的一种语言。如果只是像学习其它语言一样只是对比学习语法和关键字，无法真正掌握这门语言。这些融汇在语言中的理念，才是 Rust 最宝贵的地方。
注意在这里 “理念” 可不是什么大而化之的套话，而是实际操作中很重要的原则。
很多语言的设计初衷是 “简化”，在 Rust 中当然也有很多简化的地方，就像直接使用“let” 关键字声明一个变量，而变量的类型可以通过赋值的操作从而推导出变量的类型。比如变量超出作用域，也会被自动的回收。
但 Rust 中也大量的存在了 “复杂化” 的操作，比如上面举例的所有权机制，再比如使用可读写变量需要额外标注“mut”。
这些 “复杂化” 的部分，都基于 “尽量在程序开发的早期，就将可能会出现问题的部分暴露出来，从而在设计中和编译时就解决掉。” 这样一个理念。

#### 引用（References）和借用（Borrowing）

承接自 Rust 的拥有权机制。引用和借用在 Rust 中也迥异于大量的传统语言。
引用类似 C 语言中的指针，指向一块已经存在的数据：

```
    let mut x = 5;
    let y = &x;
```

上例中，y 就是对变量 x 的引用，并且没有标注 mut，所以是只读引用。写法跟 C 语言中获取指针的方式类似，就是一个`&`符号。
y 此时具有了变量 x 的一些权限，所以也称为 “借用”，本例中因为只借用了读的功能，没有借用写的功能，所以称 “一些”。当然也可以借用写的功能，我们后面会再举例。
借用看起来跟引用是一回事，但 “借用” 这个词更主要对应的是上面所说的所有权 “转移” 的概念，转移之后，原来的变量就无效了。而借用之后，原来的变量还有效，或者部分有效，比如只被借用了写权限。

在函数参数中，使用引用的方式，从而让函数临时性的获得数据的访问权，也是典型的借用。事实上这种方式才是最常用到借用的地方：

```
fn main() {
    fn sum_vec(v: &Vec<i32>) -> i32 {
        return v.iter().fold(0, |a, &b| a + b);
    }
    let v1 = vec![1, 2, 3];
    let s1 = sum_vec(v1);
    println!("{}", s1);
}
```

先别管我们使用到的令人困惑的关键字和函数名，那些进入到系统学习之后都不算什么。在函数 sum_vec 的参数中，我们就使用了借用。
顺便，我们还见识了 Rust 中函数的嵌套写法，当然现在新兴的语言，包括 C++11 之后的版本，都已经支持这种写法，这在函数式（Functional programming paradigm，注意不是函数化 Functionalization）编程中是很重要的支持。

引用和借用的概念，同 C/C++ 语言中所使用的都是很类似的，尽管名称不同。主要的区别来自于对引用的管理理念，Rust 对引用的管理规则如下：

*   对于一块内存，同时只能有一个可写引用存在
*   对于一块内存，同时可以有多个只读引用存在
*   对于一块内存，在有一个可写引用存在的时候，不能有其它引用存在，无论只读或者可写。
*   引用的原始对象必须在引用存在的生命期一直有效

比如：

```
    let mut x = 5;
    let y = &mut x;
    let z = &mut x;
    println!("{} {} {}", x,y,z);    
```

上面代码会产生编译错误，因为 y 已经是可写的引用，而同时再存在一个可写的引用 z，违反了 Rust 对引用的管理规则。
如果把 z 变量这一行和后面显示 z 的部分去掉呢？去掉之后是可以编译通过的，但仍然要注意，y 此时是可写的指针，“借用” 了 x 的写权限。所以 x 此时只有读的权限，不能再对 x 进行赋值。因为它已经被 “借用走”（Borrowed）了。

这些复杂的规则，看起来就跟前面见过的所有权转移一样，似乎极大的限制了程序员的自由度。
但这些都是在强迫你，让你成为一个更优秀的程序员，产生出更高质量的代码，将 Bug 消灭在萌芽期。

#### 生命期（Lifetime)

通常一个变量的生命期就是它的作用域。但在引用和借用出现后，这个问题变得复杂了。
熟悉 C 语言的程序员都碰到过数据失效了，而指针依然存在的情况，俗称 “悬挂指针”。
Java 为了解决这个问题干脆取消了指针，并且最终以引用计数器做为了内存管理的主要模式。

这种情况出现最多的场景，是在某个函数中使用了变量或者申请了内存，并将其引用作为返回值传递到了调用者的时候。比如这段 C 语言代码：

```
int *getSomeData(){
    int c=32767;
    return &c;
}
```

c 变量位于栈上，是一个局部变量，当函数返回指针的时候，指针在这个函数的调用者中依然存在，但 c 变量已经被回收了。
在新版本的编译器中，这种情况也会被警告，但可以编译成功。而在 Rust 中，这种情况是不允许编译通过的，比如下面类似代码：

```
fn somestr() -> &str {
    let result = String::from("a demo string");
    // 直接使用方法返回值(或者变量)，之后没有分号，
    // 是将其作为返回值处理，
    // 不用像c语言一样return result.as_str()
    result.as_str()
}
```

编译的时候会报错 “result 变量没有足够长的生命期”：

```
error[E0597]: `result` does not live long enough
 --> src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
```

如果仅仅是这样断然的禁止返回悬挂引用也就 “不过如此” 了。事实上更复杂的问题来自于，如果数据源来自于函数的参数，参数本身就是引用的情况。比如请看下面的 Rust 代码：

```
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x 
    } else {
        y
    }
}
```

上面这个函数接受两个字符串的引用（实际是 Slice，本文不是教学，请先忽略语法问题），比较其长度，将长的那个字符串作为结果返回调用者。顺便，这种返回值的方式一定让你印象深刻。
虽然示例简单，但不可否认，这种需求是很正当的。大量的应用场景都需要函数独立于外，处理固定的内存数据，进入和返回的，都只是指向内存的指针。
当然，尽管合理，上面的代码是无法编译通过的，报错是 “丢失生命期指定”：

```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
```

Rust 引入了生命期的概念，从而保证返回值，同给定的参数，具有相同的生命期。这即保证了程序的灵活性，而又不造成内存的泄露，同时还不把维护内存安全的责任，完全推给不可靠的人为因素。

```
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

上面的代码，添加了生命期指定。在函数名之后首先声明了生命期 a, 语法样式跟泛型的类型说明部分实际是一样的，都放在尖括号 <> 之中。生命期名称之前附加一个单引号`'`。
随后的两个引用参数 x/y 以及作为返回值的字符串引用，都直接在`&`符号之后标注了生命期`'a`。这表示，这几个引用，具有相同的生命期。
当然从这里的例子，x/y 是调用的参数，是外面传递进来的，所以完整的含义应当是：返回的引用值，同参数 x/y 一样具有相同的生命期。因此从调用者的角度来看，当 x/y 指向的内存，超出作用域销毁之后，所获得的函数返回值，也同时被销毁。

有一个特殊的生命期`'static`，用于代表 rust 中的全局量或者静态量，专门表示这种引用具有贯穿于整个程序运行时的生命期长度。
比如 Rust 中通常用字面量赋值的字符串，实际都是`'static`，因为这些字面量实际在程序编译的时候就放置到了数据区并一直存在贯穿程序始终：

```
    let s = "I have a static lifetime.";
```

#### 编译时检查和运行时开销

通过前面的几个个例子，我们对 Rust 的编译器 rustc 有了一个初步概念。丰富、详尽的编译错误输出对于排查源码中的错误帮助很大。
实际上远不止于此。Rust 的编译器包含着 Rust 语言的另外一个核心思想，那就是，尽量在编译阶段就暴露出程序的设计错误，而不让这些错误带到生产环境从而付出昂贵的代价。
这也是 Rust 学习曲线陡峭的原因之一，很多在其它语言中可以编译通过的代码，在 Rust 中都无法通过编译（排除语法错误之外）。这种更严格的编译时检查很容易让初学者手足无措。
带来的优点也是显而易见的，除了刚才提过的不让程序 Bug 带入到生产环境之外，错误能在编译阶段就消除掉，无需在运行时进行更多不必要的错误检查，这也将大大的减少程序在运行时消耗。这个消耗包括编译所生成的代码体积和运行时检查所损耗的 CPU 资源两个方面。

比如 Rust 中有多种不同功能的智能指针，以常见的 Box 和 Rc 为例，前者提供基本的指针功能，后者提供类似 Java 语言一样，基于引用统计的自动垃圾回收机制。
（请注意我们这里并不是做语言学习，所以请关注在 Rust 的设计理念上，先别在意具体的关键字和语法。）

如果在程序中使用 Box 指针的话，当变量 x 被赋值给变量 y，所有权同时被转移，变量 x 就不再可用了，这个我们在开始的所有权介绍时就见到了：

```
let x = Box::new(1);
let y = x;
// x从此无效了
```

与此规则对应的所有操作，在程序的编译器就可以做出检查，从而判断是否有错误存在。
但毕竟我们也有其它的需求，比如我们希望同时有多个指针指向同一块存储区域。这时候就需要使用 Rc 指针。

```
let five = Rc::new(5);
let five1 = five.clone();
// 此时five/five1都是有效的
```

但显然，使用 Rc 指针的时候，我们无法在编译过程中发现可能的错误。并且，Rc 指针类似 Java，当对一块内存的所有引用都失效之后，系统会释放这部分内存。而这个过程，都需要在程序执行的过程中，有对应的管理代码不停的工作，以保证跟踪内存的引用和内存的释放（垃圾回收）。这就产生了运行时开销。

为了对运行时开销能够更精确的掌控，Rust 在语言层面增加了许多选择，这些选择在其它语言中本来是不需要的。但一个经验丰富的程序员，则能充分的利用这些不同的选择写出高品质的代码。
比如 Rc 指针并不支持多线程，因为其中的引用计数器操作不是原子级的，所以 Rust 还提供了 Arc 用于多线程环境。当然，原子级的操作在运行时需要额外的开销。

与 Rust 语言的编译设计相映成趣的是 Go，Go 语言提供非常快速的编译过程，从而提供流畅的开发体验，让 Go 语言易于学习和使用。但 Go 的编译质量早就为人所诟病。
当然更极端的例子是 Python、Js 等脚本型的语言，脚本语言完全无需编译。虽然执行效率方面这些年来随着电脑性能的提高已经不是严重问题，但大多错误几乎都只能通过代码的执行来发现。使得脚本语言在商业软件开发中占有率一直不高，更别说操作系统这一类的底层软件了。

总结一下这一部分，Rust 提供高级语言所具有的一些特征，比如自动的运行时垃圾回收机制。但同时也提供并且倾向于开发人员通过精细的设计，在开发和程序编译过程中就完成内存的设计和管理，从而及早发现错误，降低运行时开销，提高最终的代码质量。

#### 有限的面向对象特征

面向对象是现代开发语言的基本能力。但 Rust 只提供了有限的面向对象支持。
我衷心的认为这是一件好事，我一直认为现在很多的程序员，往往为了面向对象而去面向对象开发。把原本很简单的事情做的过于复杂，使得代码量和运行开销高企不下，开发效率和执行效率完全失控。
Linus Torvalds 曾经在那场著名的辩论中直呼C++ 是 “糟糕程序员的垃圾语言”，有兴趣的可以翻墙去看原文：[Re: [RFC] Convert builin-mailinfo.c to use The Better String Library.](https://public-inbox.org/git/a1bbc6950709061721r537b153eu1b0bb3c27fb7bd51@mail.gmail.com/)

在 Rust 中没有直接提供 “类”(class) 的概念，希望使用 “对象” 的程序员，可以直接在结构 (struct) 和枚举 (enum) 类型上附加函数方法，比如：

```
// 声明一个“圆”结构类型
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}
// 为结构实现一个方法area
impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    // 调用结构的内置方法，计算圆的面积
    println!("{}", c.area());
}
```

看上去跟 Go 处理对象的方法很像是吧，其实在面向对象方面 Go 语言的理念也是高举了 “简化” 的大旗。
Rust 也没有我们习惯了的构造函数和析构函数。上面代码中对 Circle 对象的初始化语句：

```
let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
```

就是直接对成员变量的赋值。
这是因为 Rust 推崇 “明确化”（being explicit）的代码方式，也就是所有要执行的代码，应当清晰的在代码中体现出来。而不是隐藏在一些容易忘记、容易出错的构造函数之后。

与 “简化对象” 相反的，Rust 对面向对象中 “接口”(Java 中的 interface，或者 C++ 中的多重继承) 的概念做了发扬，贯穿在了 Rust 类型管理的方方面面。
当然我这样说有点不算贴切，其实应当先忘记 “接口” 的概念，从头理解 Rust 中的“特质”(trait)，因为特质和接口，只是在技术实现上有些类似，但在应用理念上还是很有区别的。
本质上说，“特质” 也是实现多个对象中，共性的方法，比如：

```
trait HasArea { //求取对象的面积
    fn area(&self) -> f64;
}
```

随后多个对象，都可以实现这个特质，从而都具有这个方法：

```
struct Circle { //定义一个“圆”对象
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square { //”定义一个“方形”对象
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&self) -> f64 {
        self.side * self.side
    }
}
```

在 Rust 中，通过泛型的帮助，根据数据类型实现的不同特质，把类型分为不同的功能和用途。
比如具有 “Send” 特质的类型，才可以安全的在多个线程间传递从而共享数据。
比如具有 “Copy” 特质的类型，说明数据保存在栈 (Stack) 上，数据的复制（赋值给其它变量），不会产生所有权的转移（参考前面所有权的例子）。
还有比如，刚才说过了 Rust 中没有析构函数，但如果有一些数据并没有被 Rust 所管理，需要自己去释放，则可以为自己定义的对象实现一个 Drop 特质，在其中的 drop 方法中释放自己申请的内存：

```
impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}
```

其它面向对象的编程特征，比如 “泛型”，比如 “重载”，同其它语言并没有很大的区别，这里不再额外介绍。
这些相比较其它面向对象语言而言，并不算丰富的语法工具，是保留了面向对象开发模式最精华的部分。并不会对业务的描述造成什么障碍，反而会让建模工作更为简洁、务实，尽可能不造成代码上的晦涩和运行时的低效。

#### 内置的综合管理工具

早期出现的开发语言，比如 C，比如 Java，本身并没有附加官方的管理工具。比如包管理、测试管理、编译管理。
在语言的发展过程中，因为开发工作的需求，往往会出现多个有影响的工具。在 C/C++ 方面，常见的编译管理工具有 Makefile/CMake/AutoMake 等，包管理工具，往往同系统包管理工具结合在一起，常见的有 APT/YUM/Aptitude/Dnf/HomeBrew。Java 的情况也很类似。
新近风靡的语言，比如 Python,Pip 工具占了大部分市场。Nodejs 则是 NPM 用户最多。Go 语言的同名管理工具就更不用说了。这些现象，跟语言本身的官方支持密不可分。
Rust 也由官方直接发布 Cargo 工具，功能涵盖版本升级、项目管理、包管理、测试管理、编译管理等多方面。
大多数初学者的 Rust 之旅，就是由执行`cargo new helloworld`开始的。
开发语言的综合管理工具，对于构建大型的软件项目必不可少。相信在 cargo 的帮助下，让学习者快速的学以致用，把一些项目迁移至 Rust 能轻松不少。

#### 扩展库支持

一门语言能否被大量用户支持，与语言所提供的扩展库功能密不可分。
我就见到不少程序员学习 Python 的原因，就是因为 Python 能够更好的支持 PyTorch / TensorFlow 等机器学习工具包。
Rust 通过 Crate（可以翻译为扩展箱）机制支持自己的扩展包。而且通过内置的 Cargo 工具可以直接使用大量的官方预置扩展包和社区共享的扩展包。
此外 Rust 还可以通过 FFI 接口（Foreign Function Interface）直接调用其它语言编写的函数库或者共享 Rust 函数给其它语言调用。
比如我们在 Rust 中调用 c++ 写的 snappy 压缩、解压功能包。Snappy 官方网站为：[https://google.github.io/snappy/](https://google.github.io/snappy/)，在 macOS 下安装 Snappy 包可以使用命令：`brew install snappy`。

```
extern crate libc;
use libc::size_t;

// 下面这条宏命令，表示紧接着的extern块中的函数，在snappy库中链接，
// rustc会自动链接libsnappy.dylib库
// 如果是linux则是链接libsnappy.so文件
// 如果使用宏命令：#[link(name = "snappy",kind = "static")]
// 则会链接libsnappy.a静态库文件
#[link(name = "snappy")]
extern {
    // 调用函数仅为示例，本函数估算所给定尺寸的数据，
    // 压缩后最大的长度，供用户申请输出缓存空间
    fn snappy_max_compressed_length(source_length: size_t) -> size_t;
}

fn main() {
    // 对于外部的非Rust语言库函数调用，需要在unsafe块中调用
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}
```

因为使用了 libc 扩展库，需要在 Cargo.toml 中设置库依赖：

```
[dependencies]
libc = "0.2.0"
```

编译的时候，rustc 会自动链接 libc 库和宏定义指明的 snappy 压缩解压库。

把 Rust 中定义的函数，共享给 c 语言调用也很类似，请看 Rust 代码：

```
extern crate libc;
use libc::uint32_t;

#[no_mangle]
pub extern fn add(a: uint32_t, b: uint32_t) -> uint32_t {
    a + b
}
```

上面的代码，需要设置 Cargo.toml 文件的 lib 参数：

```
[lib]
crate-type =["cdylib"]
```

从而让 rustc 将项目编译为. dylib 动态链接库文件 (macOS) 或者. so 动态链接库文件(Linux)。
对应的 C 语言代码：

```
#include <stdint.h>
extern "C" uint32_t add(uint32_t, uint32_t);

int main(){
    uint32_t sum = add(5, 5);
    return 0;
}
```

C 代码编译的时候，记着使用 - l 参数链接 rust 生成的动态链接库。
综上，迁移至 Rust 完全不用担心扩展库的限制，也完全不用担心同现有软件资源之间的互动、共享。可以从一个小的项目作为切入点，边学边用，在享受 Rust 安全可靠的同时，逐渐达成软件架构的迁移。

#### Rust 是一种可以进行底层开发的高级语言

现在流行的开发语言很多，但能够进行操作系统底层开发的选择项并没有几个。
除了传统的 C、新近的 Go，Rust 是另一个不错的选择。
做到这一点，除了 Rust 是真正的二进制编译之外，Rust 还具有非常小并且可控的 “脚印”(footprint)。这代表 Rust 可以做到完全没有自己的运行时库支持下运行。
比如官方文档中提供的一个例子：

```
#![feature(lang_items)]
#![feature(start)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -> isize {
    0
}

// These functions are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = "eh_personality"]
#[no_mangle]
pub extern fn rust_eh_personality() {
}

// This function may be needed based on the compilation target.
#[lang = "eh_unwind_resume"]
#[no_mangle]
pub extern fn rust_eh_unwind_resume() {
}

#[lang = "panic_fmt"]
#[no_mangle]
pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,
                               _file: &'static str,
                               _line: u32) -> ! {
    loop {}
}
```

其中`#![no_std]`宏代码就表示本代码编译时不使用 rust 标准库。
想要真正从头编写一个操作系统，这个话题还是比较大，有兴趣的可以参考一下这个博客：[https://os.phil-opp.com/](https://os.phil-opp.com/) 作者 Philipp Oppermann 循序渐进的演示用 Rust 在没有标准库甚至没有 libc 库的支持下从头开始编写一个操作系统，该博客提供了一个学习性的实现。

#### 其它

作为新兴的开发语言，Rust 在函数式编程、网络编程、多线程、消息同步、锁、测试代码、异常处理等方面都有不俗表现。但本文不是 Rust 教学，所以这里不再介绍。建议在学习 Rust 的过程中，根据所选教程的组织结构来逐步了解。

企业应用中，Web 框架和 ORM 是最常用到的组件，但这应当说是 Rust 当前的一个短板。
因为毕竟 Rust 是一个新兴的生态系统，尽管选择很多，但尚没有重量级的选手出现。在性能和规模化的应用方面还有待市场验证。
但 Rust 本身对内存、性能的精细管理，让我们可以对项目的总体性能保持信心。
Actix-web、hyper 的 web 框架，以及 Diesel 作为 ORM 是比较常见的组合。

#### 小结

Rust 首先包含了长期软件工程中对于高频 Bug 的经验总结，从而开创性的提出了大量的全新编程理念。
不同于很多新式语言给予开发者更多的便利和自由，Rust 更苛刻的对待程序员的开发工作...... 尽管在易用方面 Rust 也下了不少的功夫，但相对于繁复的规则，这些努力很容易被忽视。
而这些 “成长的代价” 保证了更高品质的开发输出。

比如自 2004 年以来，微软安全响应中心（MSRC）已对所有报告过的微软安全漏洞进行了分类。根据他们提供的数据，所有微软年度补丁中约有 70% 是针对内存安全漏洞的修复程序。恐怕没有人再继续做延伸统计，比如这些安全漏洞造成了多少的经济损失。
所以甚至已有传闻微软正在探索使用 Rust 编程语言作为 C、C++ 和其他语言的替代方案，以此来改善应用程序的安全状况。

Rust 并不适合初学者，只有经历过大量实践磨炼，甚至被安全漏洞痛苦折磨的资深开发者，才能更理解 Rust 的价值。

自由还是安全，终要有所取舍。